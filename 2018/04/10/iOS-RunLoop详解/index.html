<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RunLoop," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Runloop 是和线程紧密相关的一个基础组件，是很多线程有关功能的幕后功臣。尽管在平常使用中几乎不太会直接用到，理解 Runloop 有利于我们更加深入地理解 iOS 的多线程模型。 本文从如下几个方面理解RunLoop的相关知识点。  RunLoop概念 RunLoop实现 RunLoop运行 RunLoop应用  RunLoop概念RunLoop介绍 RunLoop 是什么？RunLoop">
<meta name="keywords" content="RunLoop">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS RunLoop详解">
<meta property="og:url" content="http://jackyshan.github.io/2018/04/10/iOS-RunLoop详解/index.html">
<meta property="og:site_name" content="jacky&#39;s blog">
<meta property="og:description" content="Runloop 是和线程紧密相关的一个基础组件，是很多线程有关功能的幕后功臣。尽管在平常使用中几乎不太会直接用到，理解 Runloop 有利于我们更加深入地理解 iOS 的多线程模型。 本文从如下几个方面理解RunLoop的相关知识点。  RunLoop概念 RunLoop实现 RunLoop运行 RunLoop应用  RunLoop概念RunLoop介绍 RunLoop 是什么？RunLoop">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-8916c12e771105b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-18fbf8692d37f1e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-52993d998637b711.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-356788a696d26270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-55555e0a2f40f6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-f8048787d290e431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-77fed70cd9e55b02.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-8a3a84070046eda6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-04-10T11:09:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS RunLoop详解">
<meta name="twitter:description" content="Runloop 是和线程紧密相关的一个基础组件，是很多线程有关功能的幕后功臣。尽管在平常使用中几乎不太会直接用到，理解 Runloop 有利于我们更加深入地理解 iOS 的多线程模型。 本文从如下几个方面理解RunLoop的相关知识点。  RunLoop概念 RunLoop实现 RunLoop运行 RunLoop应用  RunLoop概念RunLoop介绍 RunLoop 是什么？RunLoop">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/301129-8916c12e771105b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jackyshan.github.io/2018/04/10/iOS-RunLoop详解/"/>





  <title>iOS RunLoop详解 | jacky's blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jacky's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">宁静致远</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://jackyshan.github.io/2018/04/10/iOS-RunLoop详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jacky">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jacky's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS RunLoop详解</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T19:09:30+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/10/iOS-RunLoop详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/04/10/iOS-RunLoop详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://upload-images.jianshu.io/upload_images/301129-8916c12e771105b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Runloop 是和线程紧密相关的一个基础组件，是很多线程有关功能的幕后功臣。尽管在平常使用中几乎不太会直接用到，理解 Runloop 有利于我们更加深入地理解 iOS 的多线程模型。</p>
<p>本文从如下几个方面理解RunLoop的相关知识点。</p>
<ul>
<li>RunLoop概念</li>
<li>RunLoop实现</li>
<li>RunLoop运行</li>
<li>RunLoop应用</li>
</ul>
<h3 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h3><h4 id="RunLoop介绍"><a href="#RunLoop介绍" class="headerlink" title="RunLoop介绍"></a>RunLoop介绍</h4><blockquote>
<p>RunLoop 是什么？RunLoop 还是比较顾名思义的一个东西，说白了就是一种循环，只不过它这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 RunLoop 则是一种“闲”等待，这部分可以类比 Linux 下的 epoll。当没有事件时，RunLoop 会进入休眠状态，有事件发生时， RunLoop 会去找对应的 Handler 处理事件。RunLoop 可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠。</p>
</blockquote>
<p>从代码上看，RunLoop其实就是一个对象，它的结构如下，源码看<a href="https://opensource.apple.com/source/CF/![runloop.007.jpeg](https://upload-images.jianshu.io/upload_images/301129-feba00bde3a30349.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">这里</a><br>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;  /* locked for accessing mode list */</div><div class="line">    __CFPort _wakeUpPort;   // used for CFRunLoopWakeUp 内核向该端口发送消息可以唤醒runloop</div><div class="line">    Boolean _unused;</div><div class="line">    volatile _per_run_data *_perRunData; // reset for runs of the run loop</div><div class="line">    pthread_t _pthread;             //RunLoop对应的线程</div><div class="line">    uint32_t _winthread;</div><div class="line">    CFMutableSetRef _commonModes;    //存储的是字符串，记录所有标记为common的mode</div><div class="line">    CFMutableSetRef _commonModeItems;//存储所有commonMode的item(source、timer、observer)</div><div class="line">    CFRunLoopModeRef _currentMode;   //当前运行的mode</div><div class="line">    CFMutableSetRef _modes;          //存储的是CFRunLoopModeRef</div><div class="line">    struct _block_item *_blocks_head;//doblocks的时候用到</div><div class="line">    struct _block_item *_blocks_tail;</div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可见，一个RunLoop对象，主要包含了一个线程，若干个Mode，若干个commonMode，还有一个当前运行的Mode。</p>
<h4 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h4><p>当我们需要一个常驻线程，可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠。我们就在线程里面执行下面这个代码，一直等待消息，线程就不会退出了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">   //获取消息</div><div class="line">   //处理消息</div><div class="line">&#125; while (消息 ！= 退出)</div></pre></td></tr></table></figure>
<p>上面的这种循环模型被称作 Event Loop，事件循环模型在众多系统里都有实现，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>下图描述了Runloop运行流程（基本描述了上面Runloop的核心流程，当然可以查看官方<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">The Run Loop Sequence of Events</a>描述）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/301129-18fbf8692d37f1e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>整个流程并不复杂（需要注意的就是<em>黄色</em>区域的消息处理中并不包含source0，因为它在循环开始之初就会处理），整个流程其实就是一种<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a>的实现，其他平台均有类似的实现，只是这里叫做RunLoop。</p>
<p>RunLoop与线程的关系如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/301129-52993d998637b711.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>图中展现了 Runloop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。</p>
</blockquote>
<p>Runloop 和线程是绑定在一起的。每个线程（包括主线程）都有一个对应的 Runloop 对象。我们并不能自己创建 Runloop 对象，但是可以获取到系统提供的 Runloop 对象。</p>
<p>主线程的 Runloop 会在应用启动的时候完成启动，其他线程的 Runloop 默认并不会启动，需要我们手动启动。</p>
<h4 id="RunLoop-Mode"><a href="#RunLoop-Mode" class="headerlink" title="RunLoop Mode"></a>RunLoop Mode</h4><p>Mode可以视为事件的管家，一个Mode管理着各种事件，它的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */</div><div class="line">    CFStringRef _name;   //mode名称</div><div class="line">    Boolean _stopped;    //mode是否被终止</div><div class="line">    char _padding[3];</div><div class="line">    //几种事件</div><div class="line">    CFMutableSetRef _sources0;  //sources0</div><div class="line">    CFMutableSetRef _sources1;  //sources1</div><div class="line">    CFMutableArrayRef _observers; //通知</div><div class="line">    CFMutableArrayRef _timers;    //定时器</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap; //字典  key是mach_port_t，value是CFRunLoopSourceRef</div><div class="line">    __CFPortSet _portSet; //保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">    mach_port_t _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">    DWORD _msgQMask;</div><div class="line">    void (*_msgPump)(void);</div><div class="line">#endif</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个CFRunLoopMode对象有一个name，若干source0、source1、timer、observer和若干port，可见事件都是由Mode在管理，而RunLoop管理Mode。</p>
<p>从源码很容易看出，Runloop总是运行在某种特定的CFRunLoopModeRef下（每次运行<strong><strong>CFRunLoopRun()函数时必须指定Mode）。而通过CFRunloopRef对应结构体的定义可以很容易知道每种Runloop都可以包含若干个Mode，每个Mode又包含Source/Timer/Observer。每次调用Runloop的主函数</strong>CFRunLoopRun()时必须指定一种Mode，这个Mode称为 _currentMode</strong>，当切换Mode时必须退出当前Mode，然后重新进入Runloop以保证不同Mode的Source/Timer/Observer互不影响。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/301129-356788a696d26270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如图所示，Runloop Mode 实际上是 Source，Timer 和 Observer 的集合，不同的 Mode 把不同组的 Source，Timer 和 Observer 隔绝开来。Runloop 在某个时刻只能跑在一个 Mode 下，处理这一个 Mode 当中的 Source，Timer 和 Observer。</p>
<p>苹果文档中提到的 Mode 有五个，分别是：</p>
<ul>
<li>NSDefaultRunLoopMode</li>
<li>NSConnectionReplyMode</li>
<li>NSModalPanelRunLoopMode</li>
<li>NSEventTrackingRunLoopMode</li>
<li>NSRunLoopCommonModes</li>
</ul>
<p>iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode（注意：并不是说Runloop会运行在kCFRunLoopCommonModes这种模式下，而是相当于分别注册了 NSDefaultRunLoopMode和 UITrackingRunLoopMode。当然你也可以通过调用CFRunLoopAddCommonMode()方法将自定义Mode放到 kCFRunLoopCommonModes组合）。</p>
<p>五种Mode的介绍如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/301129-55555e0a2f40f6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="RunLoop-Source"><a href="#RunLoop-Source" class="headerlink" title="RunLoop Source"></a>RunLoop Source</h4><p>Run Loop Source分为Source、Observer、Timer三种，他们统称为ModeItem。</p>
<h5 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h5><p>根据官方的描述，CFRunLoopSource是对input sources的抽象。CFRunLoopSource分source0和source1两个版本，它的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopSource &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint32_t _bits; //用于标记Signaled状态，source0只有在被标记为Signaled状态，才会被处理</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFIndex _order;         /* immutable */</div><div class="line">    CFMutableBagRef _runLoops;</div><div class="line">    union &#123;</div><div class="line">        CFRunLoopSourceContext version0;     /* immutable, except invalidation */</div><div class="line">        CFRunLoopSourceContext1 version1;    /* immutable, except invalidation */</div><div class="line">    &#125; _context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>source0是App内部事件，由App自己管理的UIEvent、CFSocket都是source0。当一个source0事件准备执行的时候，必须要先把它标记为signal状态，以下是source0的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex version;</div><div class="line">    void *  info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void    (*release)(const void *info);</div><div class="line">    CFStringRef (*copyDescription)(const void *info);</div><div class="line">    Boolean (*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode  (*hash)(const void *info);</div><div class="line">    void    (*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void    (*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    void    (*perform)(void *info);</div><div class="line">&#125; CFRunLoopSourceContext;</div></pre></td></tr></table></figure>
<p>source0是非基于Port的。只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>
<p>source1由RunLoop和内核管理，source1带有mach_port_t，可以接收内核消息并触发回调，以下是source1的结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    CFIndex version;</div><div class="line">    void *  info;</div><div class="line">    const void *(*retain)(const void *info);</div><div class="line">    void    (*release)(const void *info);</div><div class="line">    CFStringRef (*copyDescription)(const void *info);</div><div class="line">    Boolean (*equal)(const void *info1, const void *info2);</div><div class="line">    CFHashCode  (*hash)(const void *info);</div><div class="line">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</div><div class="line">    mach_port_t (*getPort)(void *info);</div><div class="line">    void *  (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);</div><div class="line">#else</div><div class="line">    void *  (*getPort)(void *info);</div><div class="line">    void    (*perform)(void *info);</div><div class="line">#endif</div><div class="line">&#125; CFRunLoopSourceContext1;</div></pre></td></tr></table></figure>
<p>Source1除了包含回调指针外包含一个mach port，Source1可以监听系统端口和通过内核和其他线程通信，接收、分发系统事件，它能够主动唤醒RunLoop(由操作系统内核进行管理，例如CFMessagePort消息)。官方也指出可以自定义Source，因此对于CFRunLoopSourceRef来说它更像一种协议，框架已经默认定义了两种实现，如果有必要开发人员也可以自定义，详细情况可以查看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="external">官方文档</a>。</p>
<h5 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h5><p>CFRunLoopObserver是观察者，可以观察RunLoop的各种状态，并抛出回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopObserver &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFIndex _rlCount;</div><div class="line">    CFOptionFlags _activities;      /* immutable */</div><div class="line">    CFIndex _order;         /* immutable */</div><div class="line">    CFRunLoopObserverCallBack _callout; /* immutable */</div><div class="line">    CFRunLoopObserverContext _context;  /* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>CFRunLoopObserver可以观察的状态有如下6种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Run Loop Observer Activities */</div><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入run loop</div><div class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理timer</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),//即将处理source</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠</div><div class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//被唤醒但是还没开始处理事件</div><div class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),//run loop已经退出</div><div class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Runloop 通过监控 Source 来决定有没有任务要做，除此之外，我们还可以用 Runloop Observer 来监控 Runloop 本身的状态。 Runloop Observer 可以监控上面的 Runloop 事件，具体流程如下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/301129-f8048787d290e431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="CFRunLoopTimer"><a href="#CFRunLoopTimer" class="headerlink" title="CFRunLoopTimer"></a>CFRunLoopTimer</h5><p>CFRunLoopTimer是定时器，可以在设定的时间点抛出回调，它的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopTimer &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    uint16_t _bits;  //标记fire状态</div><div class="line">    pthread_mutex_t _lock;</div><div class="line">    CFRunLoopRef _runLoop;        //添加该timer的runloop</div><div class="line">    CFMutableSetRef _rlModes;     //存放所有 包含该timer的 mode的 modeName，意味着一个timer可能会在多个mode中存在</div><div class="line">    CFAbsoluteTime _nextFireDate;</div><div class="line">    CFTimeInterval _interval;     //理想时间间隔  /* immutable */</div><div class="line">    CFTimeInterval _tolerance;    //时间偏差      /* mutable */</div><div class="line">    uint64_t _fireTSR;          /* TSR units */</div><div class="line">    CFIndex _order;         /* immutable */</div><div class="line">    CFRunLoopTimerCallBack _callout;    /* immutable */</div><div class="line">    CFRunLoopTimerContext _context; /* immutable, except invalidation */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另外根据<a href="https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/c/tdef/CFRunLoopTimerRef" target="_blank" rel="external">官方文档</a>的描述，CFRunLoopTimer和NSTimer是<a href="https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677" target="_blank" rel="external">toll-free bridged</a>的，可以相互转换。</p>
<blockquote>
<p>CFRunLoopTimer is “toll-free bridged” with its Cocoa Foundation counterpart, NSTimer. This means that the Core Foundation type is interchangeable in function or method calls with the bridged Foundation object.</p>
</blockquote>
<p>所以CFRunLoopTimer具有以下特性：</p>
<ul>
<li>CFRunLoopTimer 是定时器，可以在设定的时间点抛出回调</li>
<li>CFRunLoopTimer和NSTimer是toll-free bridged的，可以相互转换</li>
</ul>
<h3 id="RunLoop实现"><a href="#RunLoop实现" class="headerlink" title="RunLoop实现"></a>RunLoop实现</h3><p>下面从以下3个方面介绍RunLoop的实现。</p>
<ul>
<li>获取RunLoop</li>
<li>添加Mode</li>
<li>添加Run Loop Source</li>
</ul>
<h4 id="获取RunLoop"><a href="#获取RunLoop" class="headerlink" title="获取RunLoop"></a>获取RunLoop</h4><p>从苹果开放的API来看，不允许我们直接创建RunLoop对象，只能通过以下几个函数来获取RunLoop:</p>
<ul>
<li>CFRunLoopRef CFRunLoopGetCurrent(void)</li>
<li>CFRunLoopRef CFRunLoopGetMain(void)</li>
<li>+(NSRunLoop *)currentRunLoop</li>
<li>+(NSRunLoop *)mainRunLoop</li>
</ul>
<p>前两个是Core Foundation中的API，后两个是Foundation中的API。</p>
<p>那么RunLoop是什么时候被创建的呢？</p>
<p>我们从下面几个函数内部看看。</p>
<h5 id="CFRunLoopGetCurrent"><a href="#CFRunLoopGetCurrent" class="headerlink" title="CFRunLoopGetCurrent"></a>CFRunLoopGetCurrent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//取当前所在线程的RunLoop</div><div class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    if (rl) return rl;</div><div class="line">    //传入当前线程</div><div class="line">    return _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopGetCurrent函数内部调用了_CFRunLoopGet0()，传入的参数是当前线程<code>pthread_self()</code>。这里可以看出，CFRunLoopGetCurrent函数必须要在线程内部调用，才能获取当前线程的RunLoop。也就是说子线程的RunLoop必须要在子线程内部获取。</p>
<h5 id="CFRunLoopGetMain"><a href="#CFRunLoopGetMain" class="headerlink" title="CFRunLoopGetMain"></a>CFRunLoopGetMain</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//取主线程的RunLoop</div><div class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    static CFRunLoopRef __main = NULL; // no retain needed</div><div class="line">    //传入主线程</div><div class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</div><div class="line">    return __main;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopGetMain函数内部也调用了_CFRunLoopGet0()，传入的参数是主线程<code>pthread_main_thread_np()</code>。可以看出，CFRunLoopGetMain()不管在主线程还是子线程中调用，都可以获取到主线程的RunLoop。</p>
<h5 id="CFRunLoopGet0"><a href="#CFRunLoopGet0" class="headerlink" title="CFRunLoopGet0"></a>CFRunLoopGet0</h5><p>前面两个函数都是使用了CFRunLoopGet0实现传入线程的函数，下面看下CFRunLoopGet0的结构是咋样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">static CFMutableDictionaryRef __CFRunLoops = NULL;</div><div class="line">static CFSpinLock_t loopsLock = CFSpinLockInit;</div><div class="line"> </div><div class="line">// t==0 is a synonym for &quot;main thread&quot; that always works</div><div class="line">//根据线程取RunLoop</div><div class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</div><div class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</div><div class="line">        t = pthread_main_thread_np();</div><div class="line">    &#125;</div><div class="line">    __CFSpinLock(&amp;loopsLock);</div><div class="line">    //如果存储RunLoop的字典不存在</div><div class="line">    if (!__CFRunLoops) &#123;</div><div class="line">        __CFSpinUnlock(&amp;loopsLock);</div><div class="line">        //创建一个临时字典dict</div><div class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        //创建主线程的RunLoop</div><div class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line">        //把主线程的RunLoop保存到dict中，key是线程，value是RunLoop</div><div class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">        //此处NULL和__CFRunLoops指针都指向NULL，匹配，所以将dict写到__CFRunLoops</div><div class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</div><div class="line">            //释放dict</div><div class="line">            CFRelease(dict);</div><div class="line">        &#125;</div><div class="line">        //释放mainrunloop</div><div class="line">        CFRelease(mainLoop);</div><div class="line">        __CFSpinLock(&amp;loopsLock);</div><div class="line">    &#125;</div><div class="line">    //以上说明，第一次进来的时候，不管是getMainRunloop还是get子线程的runloop，主线程的runloop总是会被创建</div><div class="line">    //从字典__CFRunLoops中获取传入线程t的runloop</div><div class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">    __CFSpinUnlock(&amp;loopsLock);</div><div class="line">    //如果没有获取到</div><div class="line">    if (!loop) &#123;</div><div class="line">        //根据线程t创建一个runloop</div><div class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class="line">        __CFSpinLock(&amp;loopsLock);</div><div class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">        if (!loop) &#123;</div><div class="line">            //把newLoop存入字典__CFRunLoops，key是线程t</div><div class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">            loop = newLoop;</div><div class="line">        &#125;</div><div class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</div><div class="line">        __CFSpinUnlock(&amp;loopsLock);</div><div class="line">        CFRelease(newLoop);</div><div class="line">    &#125;</div><div class="line">    //如果传入线程就是当前线程</div><div class="line">    if (pthread_equal(t, pthread_self())) &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</div><div class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">            //注册一个回调，当线程销毁时，销毁对应的RunLoop</div><div class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return loop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码可以得出以下结论：</p>
<ul>
<li>RunLoop和线程的一一对应的，对应的方式是以key-value的方式保存在一个全局字典中</li>
<li>主线程的RunLoop会在初始化全局字典时创建</li>
<li>子线程的RunLoop会在第一次获取的时候创建，如果不获取的话就一直不会被创建</li>
<li>RunLoop会在线程销毁时销毁</li>
</ul>
<h4 id="添加Mode"><a href="#添加Mode" class="headerlink" title="添加Mode"></a>添加Mode</h4><p>在Core Foundation中，针对Mode的操作，苹果只开放了以下3个API(Cocoa中也有功能一样的函数，不再列出):</p>
<ul>
<li>CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode)</li>
<li>CFStringRef CFRunLoopCopyCurrentMode(CFRunLoopRef rl)</li>
<li>CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl)</li>
</ul>
<blockquote>
<p>CFRunLoopAddCommonMode<br>Adds a mode to the set of run loop common modes.<br>向当前RunLoop的common modes中添加一个mode。</p>
<p>CFRunLoopCopyCurrentMode<br>Returns the name of the mode in which a given run loop is currently running.<br>返回当前运行的mode的name</p>
<p>CFRunLoopCopyAllModes<br>Returns an array that contains all the defined modes for a CFRunLoop object.<br>返回当前RunLoop的所有mode</p>
</blockquote>
<p>我们没有办法直接创建一个CFRunLoopMode对象，但是我们可以调用CFRunLoopAddCommonMode传入一个字符串向RunLoop中添加Mode，传入的字符串即为Mode的名字，Mode对象应该是此时在RunLoop内部创建的。下面来看一下源码。</p>
<h5 id="CFRunLoopAddCommonMode"><a href="#CFRunLoopAddCommonMode" class="headerlink" title="CFRunLoopAddCommonMode"></a>CFRunLoopAddCommonMode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef modeName) &#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    //看rl中是否已经有这个mode，如果有就什么都不做</div><div class="line">    if (!CFSetContainsValue(rl-&gt;_commonModes, modeName)) &#123;</div><div class="line">        CFSetRef set = rl-&gt;_commonModeItems ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : NULL;</div><div class="line">        //把modeName添加到RunLoop的_commonModes中</div><div class="line">        CFSetAddValue(rl-&gt;_commonModes, modeName);</div><div class="line">        if (NULL != set) &#123;</div><div class="line">            CFTypeRef context[2] = &#123;rl, modeName&#125;;</div><div class="line">            /* add all common-modes items to new mode */</div><div class="line">            //这里调用CFRunLoopAddSource/CFRunLoopAddObserver/CFRunLoopAddTimer的时候会调用</div><div class="line">            //__CFRunLoopFindMode(rl, modeName, true)，CFRunLoopMode对象在这个时候被创建</div><div class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemsToCommonMode), (void *)context);</div><div class="line">            CFRelease(set);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看得出：</p>
<ul>
<li>modeName不能重复，modeName是mode的唯一标识符</li>
<li>RunLoop的_commonModes数组存放所有被标记为common的mode的名称</li>
<li>添加commonMode会把commonModeItems数组中的所有source同步到新添加的mode中</li>
<li>CFRunLoopMode对象在CFRunLoopAddItemsToCommonMode函数中调用CFRunLoopFindMode时被创建</li>
</ul>
<h5 id="CFRunLoopCopyCurrentMode-CFRunLoopCopyAllModes"><a href="#CFRunLoopCopyCurrentMode-CFRunLoopCopyAllModes" class="headerlink" title="CFRunLoopCopyCurrentMode/CFRunLoopCopyAllModes"></a>CFRunLoopCopyCurrentMode/CFRunLoopCopyAllModes</h5><p>CFRunLoopCopyCurrentMode和CFRunLoopCopyAllModes的内部逻辑比较简单，直接取RunLoop的_currentMode和_modes返回，就不贴源码了。</p>
<h4 id="添加Run-Loop-Source（ModeItem）"><a href="#添加Run-Loop-Source（ModeItem）" class="headerlink" title="添加Run Loop Source（ModeItem）"></a>添加Run Loop Source（ModeItem）</h4><p>我们可以通过以下接口添加/移除各种事件:</p>
<ul>
<li>void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode)</li>
<li>void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode)</li>
<li>void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode)</li>
<li>void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef * mode)</li>
<li>void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode)</li>
<li>void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode)</li>
</ul>
<h5 id="CFRunLoopAddSource"><a href="#CFRunLoopAddSource" class="headerlink" title="CFRunLoopAddSource"></a>CFRunLoopAddSource</h5><p>CFRunLoopAddSource的代码结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">//添加source事件</div><div class="line">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123;    /* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</div><div class="line">    if (!__CFIsValid(rls)) return;</div><div class="line">    Boolean doVer0Callout = false;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    //如果是kCFRunLoopCommonModes</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">        //如果runloop的_commonModes存在，则copy一个新的复制给set</div><div class="line">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">       //如果runl _commonModeItems为空</div><div class="line">        if (NULL == rl-&gt;_commonModeItems) &#123;</div><div class="line">            //先初始化</div><div class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">        &#125;</div><div class="line">        //把传入的CFRunLoopSourceRef加入_commonModeItems</div><div class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rls);</div><div class="line">        //如果刚才set copy到的数组里有数据</div><div class="line">        if (NULL != set) &#123;</div><div class="line">            CFTypeRef context[2] = &#123;rl, rls&#125;;</div><div class="line">            /* add new item to all common-modes */</div><div class="line">            //则把set里的所有mode都执行一遍__CFRunLoopAddItemToCommonModes函数</div><div class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</div><div class="line">            CFRelease(set);</div><div class="line">        &#125;</div><div class="line">        //以上分支的逻辑就是，如果你往kCFRunLoopCommonModes里面添加一个source，那么所有_commonModes里的mode都会添加这个source</div><div class="line">    &#125; else &#123;</div><div class="line">        //根据modeName查找mode</div><div class="line">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</div><div class="line">        //如果_sources0不存在，则初始化_sources0，_sources0和_portToV1SourceMap</div><div class="line">        if (NULL != rlm &amp;&amp; NULL == rlm-&gt;_sources0) &#123;</div><div class="line">            rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">            rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</div><div class="line">            rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, NULL);</div><div class="line">        &#125;</div><div class="line">        //如果_sources0和_sources1中都不包含传入的source</div><div class="line">        if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources1, rls)) &#123;</div><div class="line">            //如果version是0，则加到_sources0</div><div class="line">            if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">                CFSetAddValue(rlm-&gt;_sources0, rls);</div><div class="line">                //如果version是1，则加到_sources1</div><div class="line">            &#125; else if (1 == rls-&gt;_context.version0.version) &#123;</div><div class="line">                CFSetAddValue(rlm-&gt;_sources1, rls);</div><div class="line">                __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);</div><div class="line">                if (CFPORT_NULL != src_port) &#123;</div><div class="line">                    //此处只有在加到source1的时候才会把souce和一个mach_port_t对应起来</div><div class="line">                    //可以理解为，source1可以通过内核向其端口发送消息来主动唤醒runloop</div><div class="line">                    CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);</div><div class="line">                    __CFPortSetInsert(src_port, rlm-&gt;_portSet);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            __CFRunLoopSourceLock(rls);</div><div class="line">            //把runloop加入到source的_runLoops中</div><div class="line">            if (NULL == rls-&gt;_runLoops) &#123;</div><div class="line">                rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeBagCallBacks); // sources retain run loops!</div><div class="line">            &#125;</div><div class="line">            CFBagAddValue(rls-&gt;_runLoops, rl);</div><div class="line">            __CFRunLoopSourceUnlock(rls);</div><div class="line">            if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">                if (NULL != rls-&gt;_context.version0.schedule) &#123;</div><div class="line">                    doVer0Callout = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    if (doVer0Callout) &#123;</div><div class="line">        // although it looses some protection for the source, we have no choice but</div><div class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</div><div class="line">        // where the source wants to take a lock which is already held in another</div><div class="line">        // thread which is itself waiting for a run loop/mode lock</div><div class="line">        rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName); /* CALLOUT */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过添加source的这段代码可以得出如下结论：</p>
<ul>
<li>如果modeName传入kCFRunLoopCommonModes，则该source会被保存到RunLoop的_commonModeItems中</li>
<li>如果modeName传入kCFRunLoopCommonModes，则该source会被添加到所有commonMode中</li>
<li>如果modeName传入的不是kCFRunLoopCommonModes，则会先查找该Mode，如果没有，会创建一个</li>
<li>同一个source在一个mode中只能被添加一次</li>
</ul>
<h5 id="CFRunLoopRemoveSource"><a href="#CFRunLoopRemoveSource" class="headerlink" title="CFRunLoopRemoveSource"></a>CFRunLoopRemoveSource</h5><p>remove操作和add操作的逻辑基本一致，很容易理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">//移除source</div><div class="line">void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123; /* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    Boolean doVer0Callout = false, doRLSRelease = false;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    //如果是kCFRunLoopCommonModes，则从_commonModes的所有mode中移除该source</div><div class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</div><div class="line">        if (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;_commonModeItems, rls)) &#123;</div><div class="line">            CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</div><div class="line">            CFSetRemoveValue(rl-&gt;_commonModeItems, rls);</div><div class="line">            if (NULL != set) &#123;</div><div class="line">                CFTypeRef context[2] = &#123;rl, rls&#125;;</div><div class="line">                /* remove new item from all common-modes */</div><div class="line">                CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (void *)context);</div><div class="line">                CFRelease(set);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        //根据modeName查找mode，如果不存在，返回NULL</div><div class="line">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">        if (NULL != rlm &amp;&amp; ((NULL != rlm-&gt;_sources0 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources0, rls)) || (NULL != rlm-&gt;_sources1 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources1, rls)))) &#123;</div><div class="line">            CFRetain(rls);</div><div class="line">            //根据source版本做对应的remove操作</div><div class="line">            if (1 == rls-&gt;_context.version0.version) &#123;</div><div class="line">                __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);</div><div class="line">                if (CFPORT_NULL != src_port) &#123;</div><div class="line">                    CFDictionaryRemoveValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port);</div><div class="line">                    __CFPortSetRemove(src_port, rlm-&gt;_portSet);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            CFSetRemoveValue(rlm-&gt;_sources0, rls);</div><div class="line">            CFSetRemoveValue(rlm-&gt;_sources1, rls);</div><div class="line">            __CFRunLoopSourceLock(rls);</div><div class="line">            if (NULL != rls-&gt;_runLoops) &#123;</div><div class="line">                CFBagRemoveValue(rls-&gt;_runLoops, rl);</div><div class="line">            &#125;</div><div class="line">            __CFRunLoopSourceUnlock(rls);</div><div class="line">            if (0 == rls-&gt;_context.version0.version) &#123;</div><div class="line">                if (NULL != rls-&gt;_context.version0.cancel) &#123;</div><div class="line">                    doVer0Callout = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            doRLSRelease = true;</div><div class="line">        &#125;</div><div class="line">        if (NULL != rlm) &#123;</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    if (doVer0Callout) &#123;</div><div class="line">        // although it looses some protection for the source, we have no choice but</div><div class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</div><div class="line">        // where the source wants to take a lock which is already held in another</div><div class="line">        // thread which is itself waiting for a run loop/mode lock</div><div class="line">        rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, modeName);   /* CALLOUT */</div><div class="line">    &#125;</div><div class="line">    if (doRLSRelease) CFRelease(rls);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="添加Observer和Timer"><a href="#添加Observer和Timer" class="headerlink" title="添加Observer和Timer"></a>添加Observer和Timer</h5><p>添加observer和timer的内部逻辑和添加source大体类似。</p>
<p>区别在于observer和timer只能被添加到一个RunLoop的一个或者多个mode中，比如一个timer被添加到主线程的RunLoop中，则不能再把该timer添加到子线程的RunLoop，而source没有这个限制，不管是哪个RunLoop，只要mode中没有，就可以添加。</p>
<p>这个区别在文章最开始的结构体中也可以发现，CFRunLoopSource结构体中有保存RunLoop对象的数组，而CFRunLoopObserver和CFRunLoopTimer只有单个RunLoop对象。</p>
<h3 id="RunLoop运行"><a href="#RunLoop运行" class="headerlink" title="RunLoop运行"></a>RunLoop运行</h3><p>在Core Foundation中我们可以通过以下2个API来让RunLoop运行：</p>
<ul>
<li>void CFRunLoopRun(void) </li>
</ul>
<p>在默认的mode下运行当前线程的RunLoop。</p>
<ul>
<li>CFRunLoopRunResult CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</li>
</ul>
<p>在指定mode下运行当前线程的RunLoop。</p>
<h4 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a>CFRunLoopRun</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//默认运行runloop的kCFRunLoopDefaultMode</div><div class="line">void CFRunLoopRun(void) &#123;   /* DOES CALLOUT */</div><div class="line">    int32_t result;</div><div class="line">    do &#123;</div><div class="line">        //默认在kCFRunLoopDefaultMode下运行runloop</div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopRun函数中调用了CFRunLoopRunSpecific函数，runloop参数传入当前RunLoop对象，modeName参数传入kCFRunLoopDefaultMode。验证了前面文档的解释。</p>
<h4 id="CFRunLoopRunInMode"><a href="#CFRunLoopRunInMode" class="headerlink" title="CFRunLoopRunInMode"></a>CFRunLoopRunInMode</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CFRunLoopRunInMode函数中也调用了CFRunLoopRunSpecific函数，runloop参数传入当前RunLoop对象，modeName参数继续传递CFRunLoopRunInMode传入的modeName。也验证了前面文档的解释。</p>
<p>这里还可以看出，虽然RunLoop有很多个mode，但是RunLoop在run的时候必须只能指定其中一个mode，运行起来之后，被指定的mode即为currentMode。</p>
<p>这2个函数都看不出来RunLoop是怎么run起来的。</p>
<p>接下来我们继续探索一下CFRunLoopRunSpecific函数里面都干了什么，看看RunLoop具体是怎么run的。</p>
<h4 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a>CFRunLoopRunSpecific</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 指定mode运行runloop</div><div class="line"> * @param rl 当前运行的runloop</div><div class="line"> * @param modeName 需要运行的mode的name</div><div class="line"> * @param seconds  runloop的超时时间</div><div class="line"> * @param returnAfterSourceHandled 是否处理完事件就返回</div><div class="line"> */</div><div class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    //根据modeName找到本次运行的mode</div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">    //如果没找到 || mode中没有注册任何事件，则就此停止，不进入循环</div><div class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">        Boolean did = false;</div><div class="line">        if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    //取上一次运行的mode</div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    //如果本次mode和上次的mode一致</div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    //初始化一个result为kCFRunLoopRunFinished</div><div class="line">    int32_t result = kCFRunLoopRunFinished;</div><div class="line">    </div><div class="line">    // 1.通知observer即将进入runloop</div><div class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">    //10.通知observer已退出runloop</div><div class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line">    </div><div class="line">    __CFRunLoopModeUnlock(currentMode);</div><div class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">    rl-&gt;_currentMode = previousMode;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过CFRunLoopRunSpecific的内部逻辑，我们可以得出：</p>
<ul>
<li>如果指定了一个不存在的mode来运行RunLoop，那么会失败，mode不会被创建，所以这里传入的mode必须是存在的</li>
<li>如果指定了一个mode，但是这个mode中不包含任何modeItem，那么RunLoop也不会运行，所以必须要* 传入至少包含一个modeItem的mode</li>
<li>在进入run loop之前通知observer，状态为kCFRunLoopEntry</li>
<li>在退出run loop之后通知observer，状态为kCFRunLoopExit</li>
</ul>
<p>RunLoop的运行的最核心函数是<strong>CFRunLoopRun，接下来我们分析</strong>CFRunLoopRun的源码。</p>
<h4 id="CFRunLoopRun-1"><a href="#CFRunLoopRun-1" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h4><p>这段代码比较长,请做好心理准备，我已经加了比较详细的注释。本节开头的run loop运行步骤2~9步都在下面的代码中得到验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  运行run loop</div><div class="line"> *</div><div class="line"> *  @param rl              运行的RunLoop对象</div><div class="line"> *  @param rlm             运行的mode</div><div class="line"> *  @param seconds         run loop超时时间</div><div class="line"> *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止</div><div class="line"> *  @param previousMode    上一次运行的mode</div><div class="line"> *</div><div class="line"> *  @return 返回4种状态</div><div class="line"> */</div><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    //获取系统启动后的CPU运行时间，用于控制超时时间</div><div class="line">    uint64_t startTSR = mach_absolute_time();</div><div class="line">    </div><div class="line">    //如果RunLoop或者mode是stop状态，则直接return，不进入循环</div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">        return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">        rlm-&gt;_stopped = false;</div><div class="line">        return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //mach端口，在内核中，消息在端口之间传递。 初始为0</div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</div><div class="line">    //判断是否为主线程</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    //如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    </div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        //mode赋值为dispatch端口_dispatch_runloop_root_queue_perform_4CF</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    </div><div class="line">    //GCD管理的定时器，用于实现runloop超时机制</div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</div><div class="line">    </div><div class="line">    //立即超时</div><div class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125;</div><div class="line">    //seconds为超时时间，超时时执行__CFRunLoopTimeout函数</div><div class="line">    else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</div><div class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">        timeout_context-&gt;ds = timeout_timer;</div><div class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">        dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</div><div class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125;</div><div class="line">    //永不超时</div><div class="line">    else &#123; // infinite timeout</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //标志位默认为true</div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    //记录最后runloop状态，用于return</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">        //初始化一个存放内核消息的缓冲池</div><div class="line">        uint8_t msg_buffer[3 * 1024];</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        mach_msg_header_t *msg = NULL;</div><div class="line">        mach_port_t livePort = MACH_PORT_NULL;</div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">        HANDLE livePort = NULL;</div><div class="line">        Boolean windowsMessageReceived = false;</div><div class="line">#endif</div><div class="line">        //取所有需要监听的port</div><div class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</div><div class="line">        </div><div class="line">        //设置RunLoop为可以被唤醒状态</div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</div><div class="line">        </div><div class="line">        //2.通知observer，即将触发timer回调，处理timer事件</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        //3.通知observer，即将触发Source0回调</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line">        </div><div class="line">        //执行加入当前runloop的block</div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">        //4.处理source0事件</div><div class="line">        //有事件处理返回true，没有事件返回false</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">            //执行加入当前runloop的block</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //如果没有Sources0事件处理 并且 没有超时，poll为false</div><div class="line">        //如果有Sources0事件处理 或者 超时，poll都为true</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</div><div class="line">        </div><div class="line">        //第一次do..whil循环不会走该分支，因为didDispatchPortLastTime初始化是true</div><div class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">            //从缓冲区读取消息</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //5.接收dispatchPort端口的消息，（接收source1事件）</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123;</div><div class="line">                //如果接收到了消息的话，前往第9步开始处理msg</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">            if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</div><div class="line">                goto handle_msg;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        didDispatchPortLastTime = false;</div><div class="line">        </div><div class="line">        //6.通知观察者RunLoop即将进入休眠</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">        //设置RunLoop为休眠状态</div><div class="line">        __CFRunLoopSetSleeping(rl);</div><div class="line">        // do not do any user callouts after this point (after notifying of sleeping)</div><div class="line">        </div><div class="line">        // Must push the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced.</div><div class="line">        </div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line">        </div><div class="line">        __CFRunLoopModeUnlock(rlm);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">        </div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        //这里有个内循环，用于接收等待端口的消息</div><div class="line">        //进入此循环后，线程进入休眠，直到收到新消息才跳出该循环，继续执行run loop</div><div class="line">        do &#123;</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                objc_clear_stack(0);</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //7.接收waitSet端口的消息</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">            //收到消息之后，livePort的值为msg-&gt;msgh_local_port，</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    // Leave livePort as the queue port, and service timers below</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            objc_clear_stack(0);</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        </div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</div><div class="line">        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line">        </div><div class="line">        // Must remove the local-to-this-activation ports in on every loop</div><div class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</div><div class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</div><div class="line">        // in there if this function returns.</div><div class="line">        </div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        </div><div class="line"> </div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">        </div><div class="line">        // user callouts now OK again</div><div class="line">        //取消runloop的休眠状态</div><div class="line">        __CFRunLoopUnsetSleeping(rl);</div><div class="line">        //8.通知观察者runloop被唤醒</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line">      </div><div class="line">        //9.处理收到的消息</div><div class="line">    handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">        </div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">        if (windowsMessageReceived) &#123;</div><div class="line">            // These Win32 APIs cause a callout, so make sure we&apos;re unlocked first and relocked after</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            </div><div class="line">            if (rlm-&gt;_msgPump) &#123;</div><div class="line">                rlm-&gt;_msgPump();</div><div class="line">            &#125; else &#123;</div><div class="line">                MSG msg;</div><div class="line">                if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) &#123;</div><div class="line">                    TranslateMessage(&amp;msg);</div><div class="line">                    DispatchMessage(&amp;msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            </div><div class="line">            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</div><div class="line">            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we&apos;re just checking to see if the things are signalled right now -- we will wait on them again later.</div><div class="line">            // NOTE: Ignore the dispatch source (it&apos;s not in the wait set anymore) and also don&apos;t run the observers here since we are polling.</div><div class="line">            __CFRunLoopSetSleeping(rl);</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            </div><div class="line">            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &amp;livePort, NULL);</div><div class="line">            </div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            __CFRunLoopUnsetSleeping(rl);</div><div class="line">            // If we have a new live port then it will be handled below as normal</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">#endif</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">            //通过CFRunloopWake唤醒</div><div class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</div><div class="line">            //什么都不干，跳回2重新循环</div><div class="line">            // do nothing on Mac OS</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">            // Always reset the wake up port, or risk spinning forever</div><div class="line">            ResetEvent(rl-&gt;_wakeUpPort);</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        //如果是定时器事件</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            //9.1 处理timer事件</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer, because we apparently fired early</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        //如果是定时器事件</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</div><div class="line">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</div><div class="line">           //9.1处理timer事件</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        //如果是dispatch到main queue的block</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line">#if DEPLOYMENT_TARGET_WINDOWS</div><div class="line">            void *msg = 0;</div><div class="line">#endif</div><div class="line">            //9.2执行block</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">            sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            // Despite the name, this works for windows handles as well</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            // 有source1事件待处理</div><div class="line">            if (rls) &#123;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">                mach_msg_header_t *reply = NULL;</div><div class="line">                //9.2 处理source1事件</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">                if (NULL != reply) &#123;</div><div class="line">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">                &#125;</div><div class="line">#elif DEPLOYMENT_TARGET_WINDOWS</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</div><div class="line">#endif</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">#endif</div><div class="line">        </div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        </div><div class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">            //进入run loop时传入的参数，处理完事件就返回</div><div class="line">            retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125;else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            //run loop超时</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">        &#125;else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            //run loop被手动终止</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">            retVal = kCFRunLoopRunStopped;</div><div class="line">        &#125;else if (rlm-&gt;_stopped) &#123;</div><div class="line">            //mode被终止</div><div class="line">            rlm-&gt;_stopped = false;</div><div class="line">            retVal = kCFRunLoopRunStopped;</div><div class="line">        &#125;else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">            //mode中没有要处理的事件</div><div class="line">            retVal = kCFRunLoopRunFinished;</div><div class="line">        &#125;</div><div class="line">        //除了上面这几种情况，都继续循环</div><div class="line">    &#125; while (0 == retVal);</div><div class="line">    </div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CFRunLoopServiceMachPort"><a href="#CFRunLoopServiceMachPort" class="headerlink" title="__CFRunLoopServiceMachPort"></a>__CFRunLoopServiceMachPort</h4><p>第7步调用了__CFRunLoopServiceMachPort函数，这个函数在run loop中起到了至关重要的作用，下面给出了详细注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  接收指定内核端口的消息</div><div class="line"> *</div><div class="line"> *  @param port        接收消息的端口</div><div class="line"> *  @param buffer      消息缓冲区</div><div class="line"> *  @param buffer_size 消息缓冲区大小</div><div class="line"> *  @param livePort    暂且理解为活动的端口，接收消息成功时候值为msg-&gt;msgh_local_port，超时时为MACH_PORT_NULL</div><div class="line"> *  @param timeout     超时时间，单位是ms，如果超时，则RunLoop进入休眠状态</div><div class="line"> *</div><div class="line"> *  @return 接收消息成功时返回true 其他情况返回false</div><div class="line"> */</div><div class="line">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) &#123;</div><div class="line">    Boolean originalBuffer = true;</div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    for (;;) &#123;      /* In that sleep of death what nightmares may come ... */</div><div class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = 0;  //消息头的标志位</div><div class="line">        msg-&gt;msgh_local_port = port;  //源(发出的消息)或者目标(接收的消息)</div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL; //目标(发出的消息)或者源(接收的消息)</div><div class="line">        msg-&gt;msgh_size = buffer_size;  //消息缓冲区大小，单位是字节</div><div class="line">        msg-&gt;msgh_id = 0;  //唯一id</div><div class="line">       </div><div class="line">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        </div><div class="line">        //通过mach_msg发送或者接收的消息都是指针，</div><div class="line">        //如果直接发送或者接收消息体，会频繁进行内存复制，损耗性能</div><div class="line">        //所以XNU使用了单一内核的方式来解决该问题，所有内核组件都共享同一个地址空间，因此传递消息时候只需要传递消息的指针</div><div class="line">        ret = mach_msg(msg,</div><div class="line">                       MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV),</div><div class="line">                       0,</div><div class="line">                       msg-&gt;msgh_size,</div><div class="line">                       port,</div><div class="line">                       timeout,</div><div class="line">                       MACH_PORT_NULL);</div><div class="line">        CFRUNLOOP_WAKEUP(ret);</div><div class="line">        </div><div class="line">        //接收/发送消息成功，给livePort赋值为msgh_local_port</div><div class="line">        if (MACH_MSG_SUCCESS == ret) &#123;</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //MACH_RCV_TIMEOUT</div><div class="line">        //超出timeout时间没有收到消息，返回MACH_RCV_TIMED_OUT</div><div class="line">        //此时释放缓冲区，把livePort赋值为MACH_PORT_NULL</div><div class="line">        if (MACH_RCV_TIMED_OUT == ret) &#123;</div><div class="line">            if (!originalBuffer) free(msg);</div><div class="line">            *buffer = NULL;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //MACH_RCV_LARGE</div><div class="line">        //如果接收缓冲区太小，则将过大的消息放在队列中，并且出错返回MACH_RCV_TOO_LARGE，</div><div class="line">        //这种情况下，只返回消息头，调用者可以分配更多的内存</div><div class="line">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class="line">        //此处给buffer分配更大内存</div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        if (originalBuffer) *buffer = NULL;</div><div class="line">        originalBuffer = false;</div><div class="line">        *buffer = realloc(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>RunLoop实际很简单，它是一个对象，它和线程是一一对应的，每个线程都有一个对应的RunLoop对象，主线程的RunLoop会在程序启动时自动创建，子线程需要手动获取来创建。</p>
<p>RunLoop运行的核心是一个do..while..循环，遍历所有需要处理的事件，如果有事件处理就让线程工作，没有事件处理则让线程休眠，同时等待事件到来。</p>
<h3 id="RunLoop应用"><a href="#RunLoop应用" class="headerlink" title="RunLoop应用"></a>RunLoop应用</h3><p><img src="https://upload-images.jianshu.io/upload_images/301129-77fed70cd9e55b02.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在开发过程中几乎所有的操作都是通过Call out进行回调的(无论是Observer的状态通知还是Timer、Source的处理)，而系统在回调时通常使用如下几个函数进行回调(换句话说你的代码其实最终都是通过下面几个函数来负责调用的，即使你自己监听Observer也会先调用下面的函数然后间接通知你，所以在调用堆栈中经常看到这些函数)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</div><div class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</div><div class="line">static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</div><div class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</div><div class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</div><div class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</div></pre></td></tr></table></figure>
<p>实际的代码块如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    /// 1. 通知Observers，即将进入RunLoop</div><div class="line">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</div><div class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</div><div class="line">    do &#123;</div><div class="line"> </div><div class="line">        /// 2. 通知 Observers: 即将触发 Timer 回调。</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</div><div class="line">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"> </div><div class="line">        /// 4. 触发 Source0 (非基于port的) 回调。</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"> </div><div class="line">        /// 6. 通知Observers，即将进入休眠</div><div class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</div><div class="line"> </div><div class="line">        /// 7. sleep to wait msg.</div><div class="line">        mach_msg() -&gt; mach_msg_trap();</div><div class="line">        </div><div class="line"> </div><div class="line">        /// 8. 通知Observers，线程被唤醒</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</div><div class="line"> </div><div class="line">        /// 9. 如果是被Timer唤醒的，回调Timer</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</div><div class="line"> </div><div class="line">        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</div><div class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</div><div class="line"> </div><div class="line">        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</div><div class="line"> </div><div class="line"> </div><div class="line">    &#125; while (...);</div><div class="line"> </div><div class="line">    /// 10. 通知Observers，即将退出RunLoop</div><div class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</div><div class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如在控制器的touchBegin中打入断点查看堆栈（由于UIEvent是Source0，所以可以看到一个Source0的Call out函数CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION调用）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/301129-8a3a84070046eda6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="NSTimer-与-GCD-Timer、CADisplayLink"><a href="#NSTimer-与-GCD-Timer、CADisplayLink" class="headerlink" title="NSTimer 与 GCD Timer、CADisplayLink"></a>NSTimer 与 GCD Timer、CADisplayLink</h4><h5 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h5><blockquote>
<p>前面一直提到Timer Source作为事件源，事实上它的上层对应就是NSTimer（其实就是CFRunloopTimerRef）这个开发者经常用到的定时器（底层基于使用mk_timer实现）</p>
</blockquote>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。由于 NSTimer 的这种机制，因此 NSTimer 的执行必须依赖于 RunLoop，如果没有 RunLoop，NSTimer 是不会执行的。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<h5 id="GCD-Timer"><a href="#GCD-Timer" class="headerlink" title="GCD Timer"></a>GCD Timer</h5><p>GCD 则不同，GCD 的线程管理是通过系统来直接管理的。GCD Timer 是通过 dispatch port 给 RunLoop 发送消息，来使 RunLoop 执行相应的 block，如果所在线程没有 RunLoop，那么 GCD 会临时创建一个线程去执行 block，执行完之后再销毁掉，因此 GCD 的 Timer 是不依赖 RunLoop 的。</p>
<p>至于这两个 Timer 的准确性问题，如果不在 RunLoop 的线程里面执行，那么只能使用 GCD Timer，由于 GCD Timer 是基于 MKTimer(mach kernel timer)，已经很底层了，因此是很准确的。</p>
<p>如果在 RunLoop 的线程里面执行，由于 GCD Timer 和 NSTimer 都是通过 port 发送消息的机制来触发 RunLoop 的，因此准确性差别应该不是很大。如果线程 RunLoop 阻塞了，不管是 GCD Timer 还是 NSTimer 都会存在延迟问题。</p>
<h5 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h5><p>CADisplayLink是一个执行频率（fps）和屏幕刷新相同（可以修改preferredFramesPerSecond改变刷新频率）的定时器，它也需要加入到RunLoop才能执行。与NSTimer类似，CADisplayLink同样是基于CFRunloopTimerRef实现，底层使用mk_timer（可以比较加入到RunLoop前后RunLoop中timer的变化）。和NSTimer相比它精度更高（尽管NSTimer也可以修改精度），不过和NStimer类似的是如果遇到大任务它仍然存在丢帧现象。通常情况下CADisaplayLink用于构建帧动画，看起来相对更加流畅，而NSTimer则有更广泛的用处。</p>
<h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><blockquote>
<p>AutoreleasePool是另一个与RunLoop相关讨论较多的话题。其实从RunLoop源代码分析，AutoreleasePool与RunLoop并没有直接的关系，之所以将两个话题放到一起讨论最主要的原因是因为在iOS应用启动后会注册两个Observer管理和维护AutoreleasePool。不妨在应用程序刚刚启动时打印currentRunLoop可以看到系统默认注册了很多个Observer，其中有两个Observer的callout都是<strong> _ wrapRunLoopWithAutoreleasePoolHandler</strong>，这两个是和自动释放池相关的两个监听。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;CFRunLoopObserver 0x6080001246a0 [0x101f81df0]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = &lt;CFArray 0x60800004cae0 [0x101f81df0]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;</div><div class="line">&lt;CFRunLoopObserver 0x608000124420 [0x101f81df0]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = &lt;CFArray 0x60800004cae0 [0x101f81df0]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;</div></pre></td></tr></table></figure>
<p>第一个Observer会监听RunLoop的进入，它会回调objc_autoreleasePoolPush()向当前的AutoreleasePoolPage增加一个哨兵对象标志创建自动释放池。这个Observer的order是-2147483647优先级最高，确保发生在所有回调操作之前。<br>第二个Observer会监听RunLoop的进入休眠和即将退出RunLoop两种状态，在即将进入休眠时会调用objc_autoreleasePoolPop() 和 objc_autoreleasePoolPush() 根据情况从最新加入的对象一直往前清理直到遇到哨兵对象。而在即将退出RunLoop时会调用objc_autoreleasePoolPop() 释放自动自动释放池内对象。这个Observer的order是2147483647，优先级最低，确保发生在所有回调操作之后。<br>主线程的其他操作通常均在这个AutoreleasePool之内（main函数中），以尽可能减少内存维护操作(当然你如果需要显式释放【例如循环】时可以自己创建AutoreleasePool否则一般不需要自己创建)。<br>其实在应用程序启动后系统还注册了其他Observer（例如即将进入休眠时执行注册回调_UIGestureRecognizerUpdateObserver用于手势处理、回调为_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv的Observer用于界面实时绘制更新）和多个Source1（例如context为CFMachPort的Source1用于接收硬件事件响应进而分发到应用程序一直到UIEvent）。</p>
<blockquote>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
</blockquote>
<p>自动释放池的创建和释放，销毁的时机如下所示</p>
<ul>
<li>kCFRunLoopEntry; // 进入runloop之前，创建一个自动释放池</li>
<li>kCFRunLoopBeforeWaiting; // 休眠之前，销毁自动释放池，创建一个新的自动释放池</li>
<li>kCFRunLoopExit; // 退出runloop之前，销毁自动释放池</li>
</ul>
<h4 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h4><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="external">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h4 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h4><p>如果打印App启动之后的主线程RunLoop可以发现另外一个callout为<strong>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</strong>的Observer，这个监听专门负责UI变化后的更新，比如修改了frame、调整了UI层级（UIView/CALayer）或者手动设置了setNeedsDisplay/setNeedsLayout之后就会将这些操作提交到全局容器。而这个Observer监听了主线程RunLoop的即将进入休眠和退出状态，一旦进入这两种状态则会遍历所有的UI更新并提交进行实际绘制更新。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class="line">    QuartzCore:CA::Transaction::observer_callback:</div><div class="line">        CA::Transaction::commit();</div><div class="line">            CA::Context::commit_transaction();</div><div class="line">                CA::Layer::layout_and_display_if_needed();</div><div class="line">                    CA::Layer::layout_if_needed();</div><div class="line">                        [CALayer layoutSublayers];</div><div class="line">                            [UIView layoutSubviews];</div><div class="line">                    CA::Layer::display_if_needed();</div><div class="line">                        [CALayer display];</div><div class="line">                            [UIView drawRect];</div></pre></td></tr></table></figure>
<p>通常情况下这种方式是完美的，因为除了系统的更新，还可以利用setNeedsDisplay等方法手动触发下一次RunLoop运行的更新。但是如果当前正在执行大量的逻辑运算可能UI的更新就会比较卡，因此facebook推出了<a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a>来解决这个问题。AsyncDisplayKit其实是将UI排版和绘制运算尽可能放到后台，将UI的最终更新操作放到主线程（这一步也必须在主线程完成），同时提供一套类UIView或CALayer的相关属性，尽可能保证开发者的开发习惯。这个过程中AsyncDisplayKit在主线程RunLoop中增加了一个Observer监听即将进入休眠和退出RunLoop两种状态,收到回调时遍历队列中的待处理任务一一执行。</p>
<h4 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h4><p>一旦启动NSURLConnection以后就会不断调用delegate方法接收数据，这样一个连续的的动作正是基于RunLoop来运行。<br>一旦NSURLConnection设置了delegate会立即创建一个线程<strong>com.apple.NSURLConnectionLoader</strong>，同时内部启动RunLoop并在NSDefaultMode模式下添加4个Source0。其中CFHTTPCookieStorage用于处理cookie ;CFMultiplexerSource负责各种delegate回调并在回调中唤醒delegate内部的RunLoop（通常是主线程）来执行实际操作。<br>早期版本的AFNetworking库也是基于NSURLConnection实现，为了能够在后台接收delegate回调AFNetworking内部创建了一个空的线程并启动了RunLoop，当需要使用这个后台线程执行任务时AFNetworking通过<strong>performSelector: onThread: </strong>将这个任务放到后台线程的RunLoop中。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h4 id="GCD和RunLoop的关系"><a href="#GCD和RunLoop的关系" class="headerlink" title="GCD和RunLoop的关系"></a>GCD和RunLoop的关系</h4><p>在RunLoop的源代码中可以看到用到了GCD的相关内容，但是RunLoop本身和GCD并没有直接的关系。当调用了dispatch_async(dispatch_get_main_queue(), &lt;#^(void)block#&gt;)时libDispatch会向主线程RunLoop发送消息唤醒RunLoop，RunLoop从消息中获取block，并且在<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>回调里执行这个block。不过这个操作仅限于主线程，其他线程dispatch操作是全部由libDispatch驱动的。</p>
<h4 id="更多RunLoop的实践"><a href="#更多RunLoop的实践" class="headerlink" title="更多RunLoop的实践"></a>更多RunLoop的实践</h4><h5 id="滚动Scrollview导致定时器失效"><a href="#滚动Scrollview导致定时器失效" class="headerlink" title="滚动Scrollview导致定时器失效"></a>滚动Scrollview导致定时器失效</h5><p>在界面上有一个UIScrollview控件，如果此时还有一个定时器在执行一个事件，你会发现当你滚动Scrollview的时候，定时器会失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self timer1];</div><div class="line">    [self timer2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//下面两种添加定时器的方法效果相同，都是在主线程中添加定时器</div><div class="line">- (void)timer1 &#123;</div><div class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</div><div class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopDefaultModes];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)timer2 &#123;</div><div class="line">    [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为当你滚动Scrollview的时候，RunLoop会切换到UITrackingRunLoopMode 模式，而定时器运行在defaultMode下面，系统一次只能处理一种模式的RunLoop，所以导致defaultMode下的定时器失效。</p>
<p>解决方法：</p>
<ul>
<li>把timer注册到NSRunLoopCommonModes，它包含了defaultMode和trackingMode两种模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<ul>
<li>使用GCD创建定时器，GCD创建的定时器不会受RunLoop的影响</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 获得队列</div><div class="line">dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line"></div><div class="line">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</div><div class="line">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line"></div><div class="line">// 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）</div><div class="line">// GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）</div><div class="line">// 比当前时间晚1秒开始执行</div><div class="line">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));</div><div class="line"></div><div class="line">//每隔一秒执行一次</div><div class="line">uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);</div><div class="line">dispatch_source_set_timer(self.timer, start, interval, 0);</div><div class="line"></div><div class="line">// 设置回调</div><div class="line">dispatch_source_set_event_handler(self.timer, ^&#123;</div><div class="line">    NSLog(@&quot;------------%@&quot;, [NSThread currentThread]);</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 启动定时器</div><div class="line">dispatch_resume(self.timer);</div></pre></td></tr></table></figure>
<h5 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h5><p>由于图片渲染到屏幕需要消耗较多资源，为了提高用户体验，当用户滚动Tableview的时候，只在后台下载图片，但是不显示图片，当用户停下来的时候才显示图片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;imgName&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];</div></pre></td></tr></table></figure>
<p>上面的代码可以达到如下效果：<br>用户点击屏幕，在主线程中，三秒之后显示图片，但是当用户点击屏幕之后，如果此时用户又开始滚动textview，那么就算过了三秒，图片也不会显示出来，当用户停止了滚动，才会显示图片。<br>这是因为限定了方法setImage只能在NSDefaultRunLoopMode 模式下使用。而滚动textview的时候，程序运行在tracking模式下面，所以方法setImage不会执行。</p>
<h5 id="常驻线程"><a href="#常驻线程" class="headerlink" title="常驻线程"></a>常驻线程</h5><p>需要创建一个在后台一直存在的程序，来做一些需要频繁处理的任务。比如检测网络状态等。</p>
<p>默认情况一个线程创建出来，运行完要做的事情，线程就会消亡。而程序启动的时候，就创建的主线程已经加入到RunLoop，所以主线程不会消亡。</p>
<p>这个时候我们就需要把自己创建的线程加到RunLoop中来，就可以实现线程常驻后台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class="line">    [self.thread start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)run</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;----------run----%@&quot;, [NSThread currentThread]);</div><div class="line">    @autoreleasepool&#123;</div><div class="line">    /*如果不加这句，会发现runloop创建出来就挂了，因为runloop如果没有CFRunLoopSourceRef事件源输入或者定时器，就会立马消亡。</div><div class="line">      下面的方法给runloop添加一个NSport，就是添加一个事件源，也可以添加一个定时器，或者observer，让runloop不会挂掉*/</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    </div><div class="line">    // 方法1 ,2，3实现的效果相同，让runloop无限期运行下去</div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    // 方法2</div><div class="line">    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">    </div><div class="line">    // 方法3</div><div class="line">    [[NSRunLoop currentRunLoop] runUntilDate:[NSDate distantFuture]];</div><div class="line">    </div><div class="line">    NSLog(@&quot;---------&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)test</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;----------test----%@&quot;, [NSThread currentThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class="line">    [self.thread start];</div><div class="line">&#125;</div><div class="line">- (void)run</div><div class="line">&#123;</div><div class="line">    [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES];</div><div class="line">    </div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有实现添加NSPort或者NSTimer，会发现执行完run方法，线程就会消亡，后续再执行touchbegan方法无效。</p>
<p>我们必须保证线程不消亡，才可以在后台接受时间处理</p>
<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 RunLoop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<p>可以发现执行完了run方法，这个时候再点击屏幕，可以不断执行test方法，因为线程self.thread一直常驻后台，等待事件加入其中，然后执行。</p>
<h5 id="观察事件状态，优化性能"><a href="#观察事件状态，优化性能" class="headerlink" title="观察事件状态，优化性能"></a>观察事件状态，优化性能</h5><p>假设我们想实现cell的高度缓存计算，因为“计算cell的预缓存高度”的任务需要在最无感知的时刻进行，所以应该同时满足：</p>
<ul>
<li>RunLoop 处于“空闲”状态 Mode</li>
<li>当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</div><div class="line">CFStringRef runLoopMode = kCFRunLoopDefaultMode;</div><div class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler</div><div class="line">(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123;</div><div class="line">    // TODO here</div><div class="line">&#125;);</div><div class="line">CFRunLoopAddObserver(runLoop, observer, runLoopMode);</div><div class="line">在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RunLoop/" rel="tag"># RunLoop</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/01/iOS-Runtime详解/" rel="next" title="iOS Runtime详解">
                <i class="fa fa-chevron-left"></i> iOS Runtime详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/08/iOS-KVC和KVO详解/" rel="prev" title="iOS KVC和KVO详解">
                iOS KVC和KVO详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="jacky" />
          <p class="site-author-name" itemprop="name">jacky</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/a2133b6aa395" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/5a7c14cb6fb9a0635d0c0c4f/posts" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/jackyshan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop概念"><span class="nav-number">1.</span> <span class="nav-text">RunLoop概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop介绍"><span class="nav-number">1.1.</span> <span class="nav-text">RunLoop介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop与线程"><span class="nav-number">1.2.</span> <span class="nav-text">RunLoop与线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-Mode"><span class="nav-number">1.3.</span> <span class="nav-text">RunLoop Mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-Source"><span class="nav-number">1.4.</span> <span class="nav-text">RunLoop Source</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopSource"><span class="nav-number">1.4.1.</span> <span class="nav-text">CFRunLoopSource</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopObserver"><span class="nav-number">1.4.2.</span> <span class="nav-text">CFRunLoopObserver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopTimer"><span class="nav-number">1.4.3.</span> <span class="nav-text">CFRunLoopTimer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop实现"><span class="nav-number">2.</span> <span class="nav-text">RunLoop实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取RunLoop"><span class="nav-number">2.1.</span> <span class="nav-text">获取RunLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopGetCurrent"><span class="nav-number">2.1.1.</span> <span class="nav-text">CFRunLoopGetCurrent</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopGetMain"><span class="nav-number">2.1.2.</span> <span class="nav-text">CFRunLoopGetMain</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopGet0"><span class="nav-number">2.1.3.</span> <span class="nav-text">CFRunLoopGet0</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加Mode"><span class="nav-number">2.2.</span> <span class="nav-text">添加Mode</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopAddCommonMode"><span class="nav-number">2.2.1.</span> <span class="nav-text">CFRunLoopAddCommonMode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopCopyCurrentMode-CFRunLoopCopyAllModes"><span class="nav-number">2.2.2.</span> <span class="nav-text">CFRunLoopCopyCurrentMode/CFRunLoopCopyAllModes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加Run-Loop-Source（ModeItem）"><span class="nav-number">2.3.</span> <span class="nav-text">添加Run Loop Source（ModeItem）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopAddSource"><span class="nav-number">2.3.1.</span> <span class="nav-text">CFRunLoopAddSource</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CFRunLoopRemoveSource"><span class="nav-number">2.3.2.</span> <span class="nav-text">CFRunLoopRemoveSource</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#添加Observer和Timer"><span class="nav-number">2.3.3.</span> <span class="nav-text">添加Observer和Timer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop运行"><span class="nav-number">3.</span> <span class="nav-text">RunLoop运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopRun"><span class="nav-number">3.1.</span> <span class="nav-text">CFRunLoopRun</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopRunInMode"><span class="nav-number">3.2.</span> <span class="nav-text">CFRunLoopRunInMode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopRunSpecific"><span class="nav-number">3.3.</span> <span class="nav-text">CFRunLoopRunSpecific</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopRun-1"><span class="nav-number">3.4.</span> <span class="nav-text">__CFRunLoopRun</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopServiceMachPort"><span class="nav-number">3.5.</span> <span class="nav-text">__CFRunLoopServiceMachPort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">3.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop应用"><span class="nav-number">4.</span> <span class="nav-text">RunLoop应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSTimer-与-GCD-Timer、CADisplayLink"><span class="nav-number">4.1.</span> <span class="nav-text">NSTimer 与 GCD Timer、CADisplayLink</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#NSTimer"><span class="nav-number">4.1.1.</span> <span class="nav-text">NSTimer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GCD-Timer"><span class="nav-number">4.1.2.</span> <span class="nav-text">GCD Timer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CADisplayLink"><span class="nav-number">4.1.3.</span> <span class="nav-text">CADisplayLink</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AutoreleasePool"><span class="nav-number">4.2.</span> <span class="nav-text">AutoreleasePool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件响应"><span class="nav-number">4.3.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手势识别"><span class="nav-number">4.4.</span> <span class="nav-text">手势识别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UI更新"><span class="nav-number">4.5.</span> <span class="nav-text">UI更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSURLConnection"><span class="nav-number">4.6.</span> <span class="nav-text">NSURLConnection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GCD和RunLoop的关系"><span class="nav-number">4.7.</span> <span class="nav-text">GCD和RunLoop的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更多RunLoop的实践"><span class="nav-number">4.8.</span> <span class="nav-text">更多RunLoop的实践</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#滚动Scrollview导致定时器失效"><span class="nav-number">4.8.1.</span> <span class="nav-text">滚动Scrollview导致定时器失效</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图片下载"><span class="nav-number">4.8.2.</span> <span class="nav-text">图片下载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常驻线程"><span class="nav-number">4.8.3.</span> <span class="nav-text">常驻线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#观察事件状态，优化性能"><span class="nav-number">4.8.4.</span> <span class="nav-text">观察事件状态，优化性能</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jacky</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://jackyshan.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://jackyshan.github.io/2018/04/10/iOS-RunLoop详解/';
          this.page.identifier = '2018/04/10/iOS-RunLoop详解/';
          this.page.title = 'iOS RunLoop详解';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://jackyshan.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
